import { TFile, Vault, Notice, normalizePath } from 'obsidian';
import { FoodItem, NutritionData } from '../types/nutrition';
import { PluginSettings } from '../types/settings';
import { FileUtils } from './file-utils';
import { LayoutGenerator } from './layout-generator';
import { ContentParser } from './content-parser';

export class FoodLogManager {
  private fileUtils: FileUtils;
  private layoutGenerator: LayoutGenerator;
  private contentParser: ContentParser;

  constructor(private vault: Vault, private settings: PluginSettings) {
    this.fileUtils = new FileUtils(vault);
    this.layoutGenerator = new LayoutGenerator(settings);
    this.contentParser = new ContentParser();
  }

  async createOrUpdateFoodLog(foodItems: FoodItem[], replaceEntry?: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): Promise<{ createdNewFile: boolean; filePath: string }> {
    const today = this.fileUtils.getTodayString();
    const logPath = normalizePath(`${this.settings.logStoragePath}/${today}.md`);

    try {
      // Ensure the directory exists
      await this.fileUtils.ensureDirectoryExists(this.settings.logStoragePath);

      const existingFile = this.vault.getAbstractFileByPath(logPath);
      let createdNewFile = false;

      if (existingFile instanceof TFile) {
        if (replaceEntry) {
          await this.replaceInExistingLog(existingFile, foodItems, replaceEntry);
        } else {
          await this.appendToExistingLog(existingFile, foodItems);
        }
      } else {
        await this.createNewFoodLog(logPath, foodItems);
        createdNewFile = true;
      }

      if (replaceEntry) {
        new Notice(`‚úèÔ∏è Food entry replaced in: ${today}.md`);
      } else {
        new Notice(`Food log updated: ${today}.md`);
      }

      return { createdNewFile, filePath: logPath };
    } catch (error) {
      console.error('Error creating/updating food log:', error);
      throw new Error(`Failed to save food log: ${error.message}`);
    }
  }

  async deleteFoodLogItem(itemToDelete: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): Promise<void> {
    const today = this.fileUtils.getTodayString();
    const logPath = normalizePath(`${this.settings.logStoragePath}/${today}.md`);
    
    try {
      const existingFile = this.vault.getAbstractFileByPath(logPath);
      
      if (!(existingFile instanceof TFile)) {
        throw new Error('Food log file not found for today');
      }
      
      // Read content, process it, then write back
      const existingContent = await this.vault.read(existingFile);
      const deleteResult = this.contentParser.deleteCardFromContent(existingContent, itemToDelete);
      
      if (!deleteResult.success) {
        throw new Error('Item not found in food log');
      }
      
      const finalContent = await this.recalculateTotals(deleteResult.content);
      
      // Use process to write the final content
      await this.vault.process(existingFile, () => finalContent);
    } catch (error) {
      console.error('Error deleting food log item:', error);
      throw new Error(`Failed to delete food log item: ${error.message}`);
    }
  }

  private async createNewFoodLog(path: string, foodItems: FoodItem[]): Promise<void> {
    const today = this.fileUtils.getTodayString();
    const totals = this.contentParser.calculateTotals(foodItems);
    
    let content = `# üçΩÔ∏è Food Log ${today}\n\n`;
    content += `## ü•ó Today's Meals\n\n`;
    content += this.layoutGenerator.generateCardLayout(foodItems);
    content += '\n<div class="food-placeholder"></div>\n\n';
    content += this.layoutGenerator.generateCTAButtons('foodlog');
    content += await this.layoutGenerator.generateDailySummary(totals);
    content += '\n\n---\n\n';
    content += '*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
    
    await this.vault.create(path, content);
  }

  private async appendToExistingLog(file: TFile, foodItems: FoodItem[]): Promise<void> {
    const existingContent = await this.vault.read(file);
    const placeholder = '<div class="food-placeholder"></div>';
    const placeholderIndex = existingContent.indexOf(placeholder);
    
    const newCard = this.layoutGenerator.generateCardLayout(foodItems);
    
    if (placeholderIndex !== -1) {
      // Replace placeholder with new card + new placeholder
      const updatedContent = existingContent.replace(
        placeholder,
        newCard + '\n' + placeholder
      );
      const finalContent = await this.recalculateTotals(updatedContent);
      await this.vault.process(file, () => finalContent);
    } else {
      // No placeholder found - this is an old format file, add placeholder and content
      const ctaButtonIndex = existingContent.indexOf('class="nutrition-add-cta-btn"');
      if (ctaButtonIndex !== -1) {
        const insertPosition = existingContent.lastIndexOf('<div', ctaButtonIndex);
        const beforeInsert = existingContent.substring(0, insertPosition);
        const afterInsert = existingContent.substring(insertPosition);
        const updatedContent = beforeInsert + newCard + '\n' + placeholder + '\n\n' + afterInsert;
        const finalContent = await this.recalculateTotals(updatedContent);
        await this.vault.process(file, () => finalContent);
      }
    }
  }

  private async replaceInExistingLog(file: TFile, newFoodItems: FoodItem[], originalEntry: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): Promise<void> {
    const newCardContent = this.layoutGenerator.generateCardLayout(newFoodItems);
    const existingContent = await this.vault.read(file);
    
    const replacement = this.contentParser.replaceCardInPosition(existingContent, originalEntry, newCardContent);
    
    if (replacement.success) {
      const finalContent = await this.recalculateTotals(replacement.content);
      // Use process to write the final content
      await this.vault.process(file, () => finalContent);
    } else {
      // If replacement failed, append as new entry
      await this.appendToExistingLog(file, newFoodItems);
    }
  }


  private async recalculateTotals(content: string): Promise<string> {
    const foodItems = this.contentParser.extractFoodItemsFromContent(content);
    const totals = this.contentParser.calculateTotals(foodItems);
    
    const newSummary = await this.layoutGenerator.generateDailySummary(totals);
    
    // Find the summary card
    const summaryStart = content.indexOf('<div class="ntr-summary-card');
    
    if (summaryStart !== -1) {
      // Find the matching closing div for the summary card
      const summaryBounds = this.contentParser.findCardBounds(content, summaryStart);
      
      if (summaryBounds.success) {
        // Replace existing summary
        const beforeSummary = content.substring(0, summaryStart);
        const afterSummary = content.substring(summaryBounds.endIndex);
        return beforeSummary + newSummary.trim() + afterSummary;
      }
    }
    
    // No summary exists, add it (this shouldn't happen with placeholder approach)
    const ctaButtons = this.layoutGenerator.generateCTAButtons('foodlog');
    return content.trim() + '\n\n' + ctaButtons.trim() + '\n\n' + newSummary.trim() + '\n\n---\n\n*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
  }
} 